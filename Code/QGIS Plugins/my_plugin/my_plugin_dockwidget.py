# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MyPluginDockWidget
                                 A QGIS plugin
 My first plugin in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-10-08
        git sha              : $Format:%H$
        copyright            : (C) 2021 by hengshan/SLA
        email                : li_hengshan@sla.gov.sg
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal,QThread,Qt
from qgis.core import *
from qgis.utils import iface

import geopandas as gpd
import seaborn as sb
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors

# download data
from datetime import datetime
import json
from pandas import json_normalize
import requests

from .downloader.task import DownloadRainfallTask

# Facility Site selection
from pulp import *
from shapely import wkt
from shapely.geometry import Polygon,LineString
import re

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'my_plugin_dockwidget_base.ui'))


class MyPluginDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MyPluginDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # change curent work directory to the qgis-vanguard folder
        os.chdir(r'C:\Users\user\Desktop\Projects\qgis-vanguard')

        self.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.mMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_1.setLayer)
        self.mMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_2.setLayer)
        self.btn_SP.clicked.connect(self.generateSP)
        self.comboBox_rows.addItems(np.arange(1,6,1).astype(str))
        self.comboBox_columns.addItems(np.arange(1,6,1).astype(str))
        self.mMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.updateListWidget)
        self.btn_Map.clicked.connect(self.generateMap)
        self.btn_download.clicked.connect(self.start_download_error)
        self.btn_LoadData.clicked.connect(self.load_rainfall)

        #facility location
        self.mMapLayerComboBox_Customer.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.mMapLayerComboBox_Customer.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Customer_ID.setLayer)
        self.mMapLayerComboBox_Customer.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Customer_Demand.setLayer)

        self.mMapLayerComboBox_Facility.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.mMapLayerComboBox_Facility.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Facility_ID.setLayer)
        self.mMapLayerComboBox_Facility.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Facility_Cost.setLayer)
        self.mMapLayerComboBox_Facility.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Facility_Capacity.setLayer)
        self.btn_Site.clicked.connect(self.site_selection)
    
    @staticmethod
    def compute_distance(loc1, loc2):
        import math
        dx = loc1[0] - loc2[0]
        dy = loc1[1] - loc2[1]
        return math.sqrt(dx*dx + dy*dy)

    def site_selection(self):
        if self.mFieldComboBox_Customer_ID.currentField() =="":
            return
        if self.mFieldComboBox_Customer_Demand.currentField() =="":
            return
        if self.mFieldComboBox_Facility_ID.currentField() =="":
            return
        if self.mFieldComboBox_Facility_Cost.currentField() =="":
            return
        if self.mFieldComboBox_Facility_Capacity.currentField() =="":
            return
        print('hello')
        Supermarkets_shp = self.convertToGeoPandas(self.mMapLayerComboBox_Customer.currentLayer())
        Warehouses_shp = self.convertToGeoPandas(self.mMapLayerComboBox_Facility.currentLayer())

        # SETS
        SUPERMARKETS = list(Supermarkets_shp[self.mFieldComboBox_Customer_ID.currentField()])
        WAREHOUSES =  list(Warehouses_shp[self.mFieldComboBox_Facility_ID.currentField()])
        demand = dict(zip(SUPERMARKETS,Supermarkets_shp[self.mFieldComboBox_Customer_Demand.currentField()]))
        actcost = dict(zip(WAREHOUSES,Warehouses_shp[self.mFieldComboBox_Facility_Cost.currentField()]))
        maxam = dict(zip(WAREHOUSES,Warehouses_shp[self.mFieldComboBox_Facility_Capacity.currentField()]))
        SUPERMARKETS_XY = list(zip(Supermarkets_shp.geometry.x,Supermarkets_shp.geometry.y))
        WAREHOUSES_XY = list(zip(Warehouses_shp.geometry.x,Warehouses_shp.geometry.y))
        cost_per_km = 0.02

        transp={}
        for i, wh in enumerate(WAREHOUSES):
            dist=[]
            for j, _ in enumerate(SUPERMARKETS):
                dist.append(cost_per_km * self.compute_distance(WAREHOUSES_XY[i],SUPERMARKETS_XY[j])) # warning: distance is weighted by cost
            transp[wh] = dict(zip(SUPERMARKETS,dist))
        
        prob = LpProblem("FacilityLocation",LpMinimize)
        serv_vars = LpVariable.dicts("Service", [(i,j) for i in SUPERMARKETS for j in WAREHOUSES],0)
        use_vars = LpVariable.dicts("UseLocation",WAREHOUSES,lowBound=0, upBound=1, cat=LpBinary)
        prob += lpSum(actcost[j] * use_vars[j] for j in WAREHOUSES) +\
            lpSum(transp[j][i] * serv_vars[(i,j)] for j in WAREHOUSES for i in SUPERMARKETS)

        for i in SUPERMARKETS:
            prob += lpSum(serv_vars[(i,j)] for j in WAREHOUSES) == demand[i]

        for j in WAREHOUSES:
            prob += lpSum(serv_vars[(i,j)] for i in SUPERMARKETS) <=maxam[j] * use_vars[j]

        for i in SUPERMARKETS:
            for j in WAREHOUSES:
                prob += serv_vars[(i,j)] <= demand[i] * use_vars[j]

        # The problem is solved using PuLP's choice of Solver
        prob.solve()
        print("Status:", LpStatus[prob.status])

        TOL = 0.0001
        results=[]
        for i in WAREHOUSES:
            if use_vars[i].varValue > TOL:
                print(f"Establish warehouse at: {i}.")
                results.append(i)

        for v in prob.variables():
            if v.varValue>0:
                print(v.name, "=", v.varValue)

        # select all optimal sites
        layer = self.mMapLayerComboBox_Facility.currentLayer()
        values = ','.join(str(x) for x in results)
        layer.selectByExpression('\"'+ self.mFieldComboBox_Facility_ID.currentField() +'\" IN (' + values + ')', QgsVectorLayer.SetSelection)

        # create a new line layer
        customer_id = []
        facility_id = []
        values = []
        for v in prob.variables():
            if v.varValue>0 and v.name.startswith("Service"):
                print(v.name, "=", v.varValue)
                customer_id.append(int(re.findall('\d+', v.name)[0]))
                facility_id.append(int(re.findall('\d+', v.name)[1]))
                values.append(v.varValue)

        lines = [LineString([Supermarkets_shp.query(f"Shop_ID == {i}").geometry.values[0], Warehouses_shp.query(f"WH_ID == {j}").geometry.values[0]]) for i,j in zip(customer_id,facility_id)]


        result_wh = Warehouses_shp.query(f"WH_ID == @facility_id")
        vl_result_wh = QgsVectorLayer(result_wh.to_json(),"Warehouses_results","ogr")
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(3414)
        vl_result_wh.setCrs(projectCrs)
        QgsProject.instance().addMapLayer(vl_result_wh)
        vl_result_wh.loadNamedStyle("Resources/result_wh_style.qml")
        vl_result_wh.triggerRepaint()


        result_value = pd.DataFrame({"customer_id":customer_id,"facility_id":facility_id,"value":values})
        result_lines = gpd.GeoDataFrame(result_value,geometry=lines)

        vl_result_lines = QgsVectorLayer(result_lines.to_json(),"Optimization_Line","ogr")
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(3414)
        vl_result_lines.setCrs(projectCrs)
        QgsProject.instance().addMapLayer(vl_result_lines)
        vl_result_lines.loadNamedStyle("Resources/result_line_style.qml")
        vl_result_lines.triggerRepaint()         

    def load_rainfall(self):
        # read all the downloaded file
        responses_json =[]
        for filename in os.listdir('Data/Rainfall_Download'):
            with open(os.path.join('Data/Rainfall_Download', filename), 'r') as f: # open in readonly mode
                response = json.load(f)
                responses_json.append(response)

        # create the dataframe
        df_dict=responses_json[0]
        df_stations = pd.DataFrame(df_dict['metadata']['stations'])
        df_st= df_stations.drop('location', axis=1).join(pd.DataFrame(df_stations.location.values.tolist()))
        df_rainfall = [pd.DataFrame(response['items']).assign(Day_ID=i+1, Time_ID = pd.DataFrame(response['items']).index+1) for i,response in enumerate(responses_json)]
        df_rainfall_all =pd.concat(df_rainfall, axis=0)
        df = pd.concat([pd.DataFrame(row.readings).assign(Day_ID=row.Day_ID,Time_ID=row.Time_ID) for index, row in df_rainfall_all.iterrows()]).reset_index()
        df_agg= df.groupby(['Day_ID','station_id']).sum().drop(['Time_ID','index'],axis=1).reset_index()
        df_agg_for_kriging = df_agg.merge(df_st,left_on='station_id',right_on='device_id')

        # create geodataframe
        df_rainfall_geoms = gpd.points_from_xy(x=df_agg_for_kriging["longitude"],
                                    y=df_agg_for_kriging["latitude"],
                                    crs="epsg:4326"
                                   )
        rainfall = gpd.GeoDataFrame(df_agg_for_kriging,
                                   geometry=df_rainfall_geoms
                                  )
        rainfall=rainfall.to_crs("epsg:3414")

        # load the data
        vl = QgsVectorLayer(rainfall.to_json(),"rainfall","ogr")
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(3414)
        vl.setCrs(projectCrs)
        QgsProject.instance().addMapLayer(vl)

        # render the value field 
        vl.loadNamedStyle("Resources/rainfall_style.qml")
        vl.triggerRepaint()

    def start_download_error(self):

        # access GUI date
        dt_string = f'{self.dateEdit.date().year()}-{self.dateEdit.date().month()}-{self.dateEdit.date().day()}'
        format = "%Y-%m-%d"
        dt_object = datetime.strptime(dt_string, format)
        dt_object.date()
        nDays = 10
        datelist = pd.date_range(dt_object.date(), periods= nDays).tolist()

        # download 10 days Singapore rainfall data
        for i,dt in enumerate(datelist):
            print((i+1)*100/len(datelist))
            response = requests.get('https://api.data.gov.sg/v1/environment/rainfall?date='+dt.strftime("%Y-%m-%d"))
            print(response.status_code)

            with open(f'Data/Rainfall_Download/test{i}.json', 'w') as f:
                json.dump(response.json(), f)


    def start_download(self):

        # access GUI date
        dt_string = f'{self.dateEdit.date().year()}-{self.dateEdit.date().month()}-{self.dateEdit.date().day()}'
        format = "%Y-%m-%d"
        dt_object = datetime.strptime(dt_string, format)
        dt_object.date()
        nDays = 10
        datelist = pd.date_range(dt_object.date(), periods= nDays).tolist()

        # create a qgstask and add to taskManager
        self.mytask = DownloadRainfallTask('download rainfall data task', datelist)
        QgsApplication.taskManager().addTask(self.mytask)


    def generateMap(self):
        selectedItems=[i.text() for i in self.listWidget.selectedItems()]
        if len(selectedItems)==0:
            iface.messageBar().pushMessage('select fields first')
            return

        # Set up figure and axes
        f, axs = plt.subplots(nrows=int(self.comboBox_rows.currentText()), ncols=int(self.comboBox_columns.currentText()), figsize=(24, 24))
        # Make the axes accessible with single indexing

        if len(f.get_axes())==1 and len(selectedItems)==1:
            self.convertToGeoPandas(self.mMapLayerComboBox.currentLayer()).plot(column=selectedItems[0], cmap='viridis', scheme='quantiles',
                    k=5, edgecolor='white', linewidth=0.1, alpha=0.75, legend=True, ax=axs)
            axs.set_aspect('equal')
            axs.set_axis_off()
            axs.set_title(selectedItems[0])

        elif len(selectedItems)>len(f.get_axes()):
            iface.messageBar().pushMessage('increase plot slots or decrease selected items')
            return

        else:
            axs = axs.flatten()
            self.mMapLayerComboBox.currentLayer()
            for i,item in enumerate(selectedItems):
                ax = axs[i]
                self.convertToGeoPandas(self.mMapLayerComboBox.currentLayer()).plot(column=item, cmap='viridis', scheme='quantiles',
                        k=5, edgecolor='white', linewidth=0.1, alpha=0.75, legend=True, ax=ax)
                ax.set_aspect('equal')
                ax.set_axis_off()
                ax.set_title(item)

        plt.show() 

    def updateListWidget(self):
        self.listWidget.clear()
        self.listWidget.addItems([f.name() for f in self.mMapLayerComboBox.currentLayer().fields()])

    def generateSP(self):
        sb.scatterplot(data=self.convertToPandas(self.mMapLayerComboBox.currentLayer()), 
            x=self.mFieldComboBox_1.currentField(), y=self.mFieldComboBox_2.currentField())
        plt.show()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def convertToPandas(self, layer):
        columns = [f.name() for f in layer.fields()] + ['geometry']
        columns_types = [f.typeName() for f in layer.fields()] # We exclude the geometry. Human readable
        # or
        # columns_types = [f.type() for f in layer.fields()] # QVariant type
        row_list = []
        for f in layer.getFeatures():
            row_list.append(dict(zip(columns, f.attributes() + [f.geometry().asWkt()])))

        df = pd.DataFrame(row_list, columns=columns)
        df['geometry'] = gpd.GeoSeries.from_wkt(df['geometry'])
        return df

    def convertToGeoPandas(self, layer):
        if layer is not None:
            gdf = gpd.GeoDataFrame(self.convertToPandas(layer), geometry='geometry')
            gdf = gdf.set_crs(crs=layer.crs().toWkt())
            return gdf


