# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PythonSpatialAnalysisDockWidget
                                 A QGIS plugin
 The plugin use PYSAL for spatial analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-07-26
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Singapore Land Authority
        email                : li_hengshan@sla.gov.sg
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import *
from qgis.utils import iface

import geopandas as gpd
import seaborn as sb
import pandas as pd
import numpy as np
import math
from numpy.random import seed
import matplotlib.pyplot as plt
from matplotlib import colors
from shapely import wkt
from shapely.geometry import Polygon,LineString
import re

from pysal.lib import weights
from pysal.lib import cg as geometry
from pysal.model import spreg
from pysal.explore import esda
from pysal.viz import splot
from splot.esda import plot_moran
from pandas.plotting import scatter_matrix

from sklearn.gaussian_process.kernels import RBF
from sklearn.gaussian_process import GaussianProcessRegressor
from pulp import *

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Python_Spatial_Analysis_dockwidget_base.ui'))


class PythonSpatialAnalysisDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(PythonSpatialAnalysisDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.w = None

        #change folder 
        os.chdir(r'C:\Users\user\Desktop\Projects\qgis-vanguard')
        self.sz = gpd.read_file('Data/MP14_Subzone_Y_2017.shp')

        # add combox items
        self.comboBox_weights.addItem("Rook")
        self.comboBox_weights.addItem("Queen")
        self.comboBox_weights.addItem("KNN")

        self.comboBox_knn.addItems(np.arange(1,11,1).astype(str))
        self.comboBox_knn.hide()

        self.comboBox_rows.addItems(np.arange(1,6,1).astype(str))
        self.comboBox_columns.addItems(np.arange(1,6,1).astype(str))

        # sync layer comboBox and Fields
        self.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.mMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_1.setLayer)
        self.mMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_2.setLayer)

        # click events
        self.mMapLayerComboBox.currentIndexChanged.connect(self.updateLayer)
        self.mFieldComboBox_1.currentIndexChanged.connect(self.updateField1)
        self.mFieldComboBox_2.currentIndexChanged.connect(self.updateField2)
        self.comboBox_weights.currentIndexChanged.connect(self.chooseWeight)
        self.Histgram.clicked.connect(self.generateHistgram)
        self.Describe.clicked.connect(self.generateDescribe)
        self.G_Morans_I.clicked.connect(self.gMoranI)
        self.L_Morans_I.clicked.connect(self.lMoranI)
        self.ScatterPlot.clicked.connect(self.generateScatterPlot)
        self.SpatialWeights.clicked.connect(self.calculateSpatialWeights)
        self.Corr_fields.clicked.connect(self.generateCorr)
        self.choropleth_map.clicked.connect(self.generateMap)

        # global layer and geopandas layer
        self.layer = self.mMapLayerComboBox.currentLayer()
        self.gpd_layer=self.convertToGeoPandas(self.layer)
        self.field1 = self.mFieldComboBox_1.currentField()
        self.field2 = self.mFieldComboBox_2.currentField()

        ########## Spatial interpolcation events
        # push button event to load rainfall data
        self.btn_Read_rainfall.clicked.connect(self.loadRainfall)
        # push button event to interpolate
        self.btn_Interpolate.clicked.connect(self.interpolate)
        # slider events
        self.sl_rainfall.valueChanged.connect(self.slValuechange)

        ########## Spatial regression events
        self.btn_regression.clicked.connect(self.regression)
        self.btn_SpatialReg.clicked.connect(self.spatialRegression)

        ########## spatial optimization
        self.mMapLayerComboBox_Customer.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.mMapLayerComboBox_Customer.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Customer_ID.setLayer)
        self.mMapLayerComboBox_Customer.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Customer_Demand.setLayer)

        self.mMapLayerComboBox_Facility.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.mMapLayerComboBox_Facility.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Facility_ID.setLayer)
        self.mMapLayerComboBox_Facility.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Facility_Cost.setLayer)
        self.mMapLayerComboBox_Facility.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBox_Facility_Capacity.setLayer)
        self.horizontalSlider_weight.valueChanged.connect(self.slWeightValuechange)
        self.transport_weight = self.horizontalSlider_weight.value()
        self.btn_optimize.clicked.connect(self.optimize)

    def slWeightValuechange(self):
        self.transport_weight = self.horizontalSlider_weight.value()

    def compute_distance(self, loc1, loc2):
        dx = loc1[0] - loc2[0]
        dy = loc1[1] - loc2[1]
        return math.sqrt(dx*dx + dy*dy)

    def optimize(self):
        if self.mFieldComboBox_Customer_ID.currentField() =="":
            return
        if self.mFieldComboBox_Customer_Demand.currentField() =="":
            return
        if self.mFieldComboBox_Facility_ID.currentField() =="":
            return
        if self.mFieldComboBox_Facility_Cost.currentField() =="":
            return
        if self.mFieldComboBox_Facility_Capacity.currentField() =="":
            return
        
        Supermarkets_shp = self.convertToGeoPandas(self.mMapLayerComboBox_Customer.currentLayer())
        Warehouses_shp = self.convertToGeoPandas(self.mMapLayerComboBox_Facility.currentLayer())

        # SETS
        SUPERMARKETS = list(Supermarkets_shp[self.mFieldComboBox_Customer_ID.currentField()])
        WAREHOUSES =  list(Warehouses_shp[self.mFieldComboBox_Facility_ID.currentField()])
        demand = dict(zip(SUPERMARKETS,Supermarkets_shp[self.mFieldComboBox_Customer_Demand.currentField()]))
        actcost = dict(zip(WAREHOUSES,Warehouses_shp[self.mFieldComboBox_Facility_Cost.currentField()]))
        maxam = dict(zip(WAREHOUSES,Warehouses_shp[self.mFieldComboBox_Facility_Capacity.currentField()]))
        SUPERMARKETS_XY = list(zip(Supermarkets_shp.geometry.x,Supermarkets_shp.geometry.y))
        WAREHOUSES_XY = list(zip(Warehouses_shp.geometry.x,Warehouses_shp.geometry.y))
        cost_per_km = self.transport_weight/1000

        transp={}
        for i, wh in enumerate(WAREHOUSES):
            dist=[]
            for j, _ in enumerate(SUPERMARKETS):
                dist.append(cost_per_km * self.compute_distance(WAREHOUSES_XY[i],SUPERMARKETS_XY[j])) # warning: distance is weighted by cost
            transp[wh] = dict(zip(SUPERMARKETS,dist))
        
        prob = LpProblem("FacilityLocation",LpMinimize)
        serv_vars = LpVariable.dicts("Service", [(i,j) for i in SUPERMARKETS for j in WAREHOUSES],0)
        use_vars = LpVariable.dicts("UseLocation",WAREHOUSES,lowBound=0, upBound=1, cat=LpBinary)
        prob += lpSum(actcost[j] * use_vars[j] for j in WAREHOUSES) +\
            lpSum(transp[j][i] * serv_vars[(i,j)] for j in WAREHOUSES for i in SUPERMARKETS)

        for i in SUPERMARKETS:
            prob += lpSum(serv_vars[(i,j)] for j in WAREHOUSES) == demand[i]

        for j in WAREHOUSES:
            prob += lpSum(serv_vars[(i,j)] for i in SUPERMARKETS) <=maxam[j] * use_vars[j]

        for i in SUPERMARKETS:
            for j in WAREHOUSES:
                prob += serv_vars[(i,j)] <= demand[i] * use_vars[j]

        # The problem is solved using PuLP's choice of Solver
        prob.solve()
        print("Status:", LpStatus[prob.status])

        TOL = 0.0001
        results=[]
        for i in WAREHOUSES:
            if use_vars[i].varValue > TOL:
                print(f"Establish warehouse at: {i}.")
                results.append(i)

        for v in prob.variables():
            if v.varValue>0:
                print(v.name, "=", v.varValue)

        # select all optimal sites
        layer = self.mMapLayerComboBox_Facility.currentLayer()
        values = ','.join(str(x) for x in results)
        layer.selectByExpression('\"'+ self.mFieldComboBox_Facility_ID.currentField() +'\" IN (' + values + ')', QgsVectorLayer.SetSelection)

        # create a new line layer
        customer_id = []
        facility_id = []
        values = []
        for v in prob.variables():
            if v.varValue>0 and v.name.startswith("Service"):
                print(v.name, "=", v.varValue)
                customer_id.append(int(re.findall('\d+', v.name)[0]))
                facility_id.append(int(re.findall('\d+', v.name)[1]))
                values.append(v.varValue)

        lines = [LineString([Supermarkets_shp.query(f"Shop_ID == {i}").geometry.values[0], Warehouses_shp.query(f"WH_ID == {j}").geometry.values[0]]) for i,j in zip(customer_id,facility_id)]


        result_wh = Warehouses_shp.query(f"WH_ID == @facility_id")
        vl_result_wh = QgsVectorLayer(result_wh.to_json(),"Warehouses_results","ogr")
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(3414)
        vl_result_wh.setCrs(projectCrs)
        QgsProject.instance().addMapLayer(vl_result_wh)
        vl_result_wh.loadNamedStyle("Resources/result_wh_style.qml")
        vl_result_wh.triggerRepaint()


        result_value = pd.DataFrame({"customer_id":customer_id,"facility_id":facility_id,"value":values})
        result_lines = gpd.GeoDataFrame(result_value,geometry=lines)

        vl_result_lines = QgsVectorLayer(result_lines.to_json(),"Optimization_Line","ogr")
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(3414)
        vl_result_lines.setCrs(projectCrs)
        QgsProject.instance().addMapLayer(vl_result_lines)
        vl_result_lines.loadNamedStyle("Resources/result_line_style.qml")
        vl_result_lines.triggerRepaint() 

    def regression(self):
        dependent_vars = [i.text() for i in self.listWidget_dep.selectedItems()]
        if len(dependent_vars)==0:
            print("require dependent variable")
            return

        independent_vars = [i.text() for i in self.listWidget_Indep.selectedItems()]
        if len(independent_vars)==0:
            print("require independent variables")
            return

        Y = self.listWidget_dep.selectedItems()[0].text()
        variable_names_X = [i.text() for i in self.listWidget_Indep.selectedItems()]

        m_ols = spreg.OLS(
            self.gpd_layer[[Y]].values, 
            self.gpd_layer[variable_names_X].values,
            name_y=Y, 
            name_x=variable_names_X
        )
        print(m_ols.summary)

    def spatialRegression(self):
        dependent_vars = [i.text() for i in self.listWidget_dep.selectedItems()]
        if len(dependent_vars)==0:
            print("require dependent variable")
            return

        independent_vars = [i.text() for i in self.listWidget_Indep.selectedItems()]
        if len(independent_vars)==0:
            print("require independent variables")
            return

        if self.w is None:
            print("calculate spatial weights first")
            return

        Y = self.listWidget_dep.selectedItems()[0].text()
        variable_names_X = [i.text() for i in self.listWidget_Indep.selectedItems()]

        m_GM_Lag = spreg.GM_Lag(
            self.gpd_layer[[Y]].values, 
            self.gpd_layer[variable_names_X].values,
            w=self.w,
            name_y=Y,
            name_x=variable_names_X
        )
        print(m_GM_Lag.summary)

    def interpolate(self):

        # get the current layer start with rainfall
        if not iface.activeLayer().name().startswith("rainfall"):
            print("select a rainfall point layer")
            return

        vl = iface.activeLayer()
        rainfall_day = self.convertToGeoPandas(vl)

        # prepare points for interpolation
        extent = min_x, max_x, min_y, max_y = [self.rainfall.geometry.x.min()-1100, self.rainfall.geometry.x.max()+10000, self.rainfall.geometry.y.min()-6500, self.rainfall.geometry.y.max()+5200]
        gridx, gridy = np.mgrid[min_x:max_x:500, min_y:max_x:500]
        gridxy = np.stack([gridx.ravel(), gridy.ravel()]).T

        # interpolation
        points = np.vstack((rainfall_day.geometry.x,rainfall_day.geometry.y)).T
        kernel = RBF(length_scale=1000)
        gp = GaussianProcessRegressor(normalize_y=True,
                                      alpha=0.1,  # Larger values imply more noise in the input data.
                                      kernel=kernel)

        gp.fit(points, rainfall_day.value.values)
        grid_points_pred =gp.predict(gridxy)
        grid_points = gpd.points_from_xy(x=gridxy[:,0], y=gridxy[:,1])
        grid_points_df = gpd.GeoDataFrame(pd.DataFrame(grid_points_pred,columns=['value']), geometry=grid_points)

        grid_points_within = gpd.sjoin(grid_points_df, self.sz, how='inner', op='within')
        
        vl_krige = QgsVectorLayer(grid_points_within.to_json(),vl.name()+"Interpolation","ogr")
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(3414)
        vl_krige.setCrs(projectCrs)
        QgsProject.instance().addMapLayer(vl_krige)
        vl_krige.loadNamedStyle("Resources/rainfall_krige_style.qml")
        vl_krige.triggerRepaint()

    def loadRainfall(self):
        # load files
        self.rainfall = gpd.read_file('Data/rainfall.shp')
        rainfall_day=self.rainfall.query('Day_ID == ' + str(self.sl_rainfall.value()))
        vl = QgsVectorLayer(rainfall_day.to_json(),"rainfall_day"+str(self.sl_rainfall.value()),"ogr")
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(3414)
        vl.setCrs(projectCrs)
        QgsProject.instance().addMapLayer(vl)

        # render the value field 
        vl.loadNamedStyle("Resources/rainfall_style.qml")
        vl.triggerRepaint()

    def slValuechange(self):
        day_id = self.sl_rainfall.value()
        print(day_id)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    ### Customized methods
    def generateCorr(self):
        selectedItems=[i.text() for i in self.listWidget_fields_corr.selectedItems()]
        if len(selectedItems)==0:
            print("select fields first")
            return

        print(self.gpd_layer[selectedItems].corr())
        scatter_matrix(self.gpd_layer[selectedItems],figsize  = [20, 20])
        plt.show()

    def generateMap(self):
        selectedItems=[i.text() for i in self.listWidget_fields_map.selectedItems()]
        if len(selectedItems)==0:
            print("select fields first")
            return

        # Set up figure and axes
        f, axs = plt.subplots(nrows=int(self.comboBox_rows.currentText()), ncols=int(self.comboBox_columns.currentText()), figsize=(24, 24))
        # Make the axes accessible with single indexing

        if len(f.get_axes())==1 and len(selectedItems)==1:
            self.gpd_layer.plot(column=selectedItems[0], cmap='viridis', scheme='quantiles',
                    k=5, edgecolor='white', linewidth=0.1, alpha=0.75, legend=True, ax=axs)
            axs.set_aspect('equal')
            axs.set_axis_off()
            axs.set_title(selectedItems[0])

        elif len(selectedItems)>len(f.get_axes()):
            print("increase plot slots or decrease selected items")
            return

        else:
            axs = axs.flatten()

            for i,item in enumerate(selectedItems):
                ax = axs[i]
                self.gpd_layer.plot(column=item, cmap='viridis', scheme='quantiles',
                        k=5, edgecolor='white', linewidth=0.1, alpha=0.75, legend=True, ax=ax)
                ax.set_aspect('equal')
                ax.set_axis_off()
                ax.set_title(item)

        plt.show()

    def calculateSpatialWeights(self):
        if self.field1 is None:
            return
                # get spatial spatial weights
        if self.comboBox_weights.currentText()== "Rook":
            self.w = weights.contiguity.Rook.from_dataframe(self.gpd_layer)
        elif self.comboBox_weights.currentText()=="Queen":
            self.w = weights.contiguity.Queen.from_dataframe(self.gpd_layer)
        else:
            self.w = weights.distance.KNN.from_dataframe(self.gpd_layer, k=int(self.comboBox_knn.currentText()))
        self.w.transform = 'R'

        print(self.w.neighbors)
        print(self.w.weights)

        ax = self.gpd_layer.plot(edgecolor='k', facecolor='w',figsize=(10,5))
        self.w.plot(self.gpd_layer, ax=ax, 
                edge_kws=dict(color='r', linestyle=':', linewidth=1),
                node_kws=dict(marker=''))
        ax.set_axis_off()
        plt.show()

    def generateScatterPlot(self):
        if self.field2 is None or self.field1 is None:
            return
        sb.scatterplot(data=self.gpd_layer, x=self.field1, y=self.field2)
        plt.show()


    def updateLayer(self):
        if self.mMapLayerComboBox.currentLayer() is None:
            return
            
        self.layer = self.mMapLayerComboBox.currentLayer()
        self.gpd_layer=self.convertToGeoPandas(self.layer)
        self.field1 = self.mFieldComboBox_1.currentField()
        self.field2 = self.mFieldComboBox_2.currentField()

        # update the fields_corr and fields_map
        
        self.listWidget_fields_corr.clear()
        self.listWidget_fields_corr.addItems([f.name() for f in self.layer.fields()])

        self.listWidget_fields_map.clear()
        self.listWidget_fields_map.addItems([f.name() for f in self.layer.fields()])

        self.listWidget_dep.clear()
        self.listWidget_dep.addItems([f.name() for f in self.layer.fields()])

        self.listWidget_Indep.clear()
        self.listWidget_Indep.addItems([f.name() for f in self.layer.fields()])

    def updateField1(self):
        self.field1 = self.mFieldComboBox_1.currentField()

    def updateField2(self):
        self.field2 = self.mFieldComboBox_2.currentField()

    def chooseWeight(self):
        if self.comboBox_weights.currentText()=="KNN":
            self.comboBox_knn.show()
        else:
            self.comboBox_knn.hide()

    def generateHistgram(self): 
        sb.histplot(data=self.gpd_layer, x=self.field1)
        plt.show()

    def generateDescribe(self): 
        print(self.gpd_layer.describe())

    def gMoranI(self):
        if self.w is None:
            print("Need to run spatial weights first")
            return

        if not pd.api.types.is_numeric_dtype(self.gpd_layer[self.field1]):
            print("The field must be numeric to run Moran's I")
            return

        moran = esda.moran.Moran(self.gpd_layer[self.field1], self.w)
        plot_moran(moran)
        plt.show()
        print(f"moran.I: {moran.I} \n moran.p_sim: {moran.p_sim}")


    def lMoranI(self):
        if self.w is None:
            print("Need to run spatial weights first")
            return

        if not pd.api.types.is_numeric_dtype(self.gpd_layer[self.field1]):
            print("The field must be numeric to run Moran's I")
            return

        if len(self.w.islands)>0:
            print("Local Moran's I cannot run on weights with islands. May consider to use KNN")
            return

        lisa = esda.moran.Moran_Local(self.gpd_layer[self.field1], self.w)
        self.gpd_layer['Is'] = lisa.Is

        # Set up figure and axes
        f, axs = plt.subplots(nrows=2, ncols=2, figsize=(24, 12))
        # Make the axes accessible with single indexing
        axs = axs.flatten()

        # Subplot 1 #
        ax = axs[0]
        self.gpd_layer.plot(column='Is', cmap='viridis', scheme='quantiles',
                k=5, edgecolor='white', linewidth=0.1, alpha=0.75, legend=True, ax=ax)
        ax.set_aspect('equal')
        ax.set_axis_off()

        # Subplot 2 #
        ax = axs[1]
        q_labels = ['Q1', 'Q2', 'Q3', 'Q4']
        labels = [q_labels[i-1] for i in lisa.q]
        hmap = colors.ListedColormap([ 'red', 'lightblue', 'blue', 'pink'])
        self.gpd_layer.assign(cl=labels).plot(column='cl', categorical=True, \
                k=2, cmap=hmap, linewidth=0.1, ax=ax, \
                edgecolor='white', legend=True)

        ax.set_aspect('equal')
        ax.set_axis_off()

        # Subplot 3 #
        ax = axs[2]
        sig = 1 * (lisa.p_sim < 0.05)
        hmap = colors.ListedColormap(['grey','black'])
        labels = ['non-sig.', 'significant'] 
        labels = [labels[i] for i in sig]
        self.gpd_layer.assign(cl=labels).plot(column='cl', categorical=True, \
                k=2, cmap=hmap, linewidth=0.1, ax=ax, \
                edgecolor='white', legend=True)

        ax.set_aspect('equal')
        ax.set_axis_off()
                                    
        # Subplot 4 #
        ax = axs[3]
        hotspot = 1 * (sig * lisa.q==1)
        coldspot = 3 * (sig * lisa.q==3)
        doughnut = 2 * (sig * lisa.q==2)
        diamond = 4 * (sig * lisa.q==4)
        spots = hotspot + coldspot + doughnut + diamond
        spot_labels = [ '0 ns', '1 hot spot', '2 doughnut', '3 cold spot', '4 diamond']
        labels = [spot_labels[i] for i in spots]
        hmap = colors.ListedColormap([ 'grey', 'red', 'lightblue', 'blue', 'pink'])


        self.gpd_layer.assign(cl=labels).plot(column='cl', categorical=True, \
                k=2, cmap=hmap, linewidth=0.1, ax=ax, \
                edgecolor='white', legend=True)

        ax.set_aspect('equal')
        ax.set_axis_off()

        f.canvas.set_window_title("Local Moran's I") 

        # Display the figure
        plt.show()


    def convertToPandas(self, layer):
        columns = [f.name() for f in layer.fields()] + ['geometry']
        columns_types = [f.typeName() for f in layer.fields()] # We exclude the geometry. Human readable
        # or
        # columns_types = [f.type() for f in layer.fields()] # QVariant type
        row_list = []
        for f in layer.getFeatures():
            row_list.append(dict(zip(columns, f.attributes() + [f.geometry().asWkt()])))

        df = pd.DataFrame(row_list, columns=columns)
        df['geometry'] = gpd.GeoSeries.from_wkt(df['geometry'])
        return df

    def convertToGeoPandas(self, layer):
        if layer is not None:
            gdf = gpd.GeoDataFrame(self.convertToPandas(layer), geometry='geometry')
            gdf = gdf.set_crs(crs=layer.crs().toWkt())
            return gdf